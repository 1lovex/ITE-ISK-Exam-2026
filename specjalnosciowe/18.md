# Pytanie 18. Metody projektowania gier komputerowych

## Kuba

Projektowanie gier komputerowych to proces tworzenia zasad, mechanik, fabuły i estetyki gry wideo, skupiający się na doświadczeniu gracza (User Experience). W przeciwieństwie do tradycyjnych modeli cyklu życia oprogramowania (jak kaskadowy), produkcja gier rzadko zaczyna się od jednoznacznych wymogów, dlatego najczęściej stosuje się metodyki zwinne (Agile). Cały proces dzieli się na trzy główne etapy: preprodukcję, produkcję właściwą oraz postprodukcję (konserwację).

### Etap Preprodukcji – Serce Projektowania

Preprodukcja to najważniejszy etap z punktu widzenia projektanta. To tutaj zapada decyzja, "jaka" będzie gra, jak będzie działać i czy jej stworzenie jest technicznie możliwe. Jest to faza intensywnego tworzenia dokumentacji i eksperymentów.

#### Ewolucja Dokumentacji (GDD)

Kluczowym dokumentem, który powstaje i ewoluuje w tej fazie, jest GDD (Game Design Document). Jest to "biblia projektu", która opisuje każdy detal gry. Dokumentacja tworzona jest sekwencyjnie:

- **High Concept / Game Concept:** Jednostronicowy opis głównego pomysłu (tzw. elevator pitch). Określa gatunek, grupę docelową i unikalne cechy gry (Unique Selling Points). Przykład: "Minecraft to sandboxowa gra survivalowa, gdzie gracze budują i eksplorują świat z klocków, skierowana do kreatywnych osób w każdym wieku."
- **Vision Document (Początek GDD):** Definiuje Filary Gry (Core Pillars) – 3-4 podstawowe zasady, którym musi odpowiadać każdy element rozgrywki. Zawiera analizę technologii (silnik: Unity, Unreal, własny) oraz wstępne założenia mechaniki. Przykład filarów: Eksploracja, Budowa, Przetrwanie.
- **Art Design Document:** Instrukcje wizualne (tzw. Style Guide). Zawiera tablice nastroju (Moodboards), szkice koncepcyjne i palety kolorystyczne, które definiują klimat świata. Przykład: Dla gry fantasy – kolory ziemi, zieleni, z akcentami złota.
- **Technical Design Document (TDD):** Opisuje architekturę kodu, systemy AI, strukturę bazy danych oraz sposób implementacji mechanik opisanych w GDD. Pozwala na wczesne wykrycie "wąskich gardeł" technologicznych. Przykład: Architektura oparta na ECS (Entity Component System) dla lepszej wydajności.

#### Projektowanie Systemów i Poziomów (Design)

W fazie preprodukcji projektowanie dzieli się na kilka specjalistycznych obszarów:

- **System Design:** Projektowanie reguł matematycznych, balansu ekonomii w grze, statystyk postaci i interakcji między systemami (np. jak pogoda wpływa na walkę). Przykład: W grze RPG – system zdrowia postaci regeneruje się szybciej w deszczu, ale zmniejsza się zasięg widzenia.
- **Level Design i Grayboxing:** Tworzenie wstępnych układów poziomów z prostych brył (szarych pudełek). Pozwala to sprawdzić tempo rozgrywki i nawigację bez angażowania grafików. Przykład: W FPS – rozmieszczenie osłon i ścieżek dla płynnego przepływu walki.
- **Narrative Design:** Budowanie świata (Lore), pisanie scenariusza, dialogów i projektowanie zadań (questów) w taki sposób, by opowiadały historię poprzez rozgrywkę. Przykład: W grze przygodowej – questy ujawniają historię stopniowo przez interakcje z NPC.

#### Prototypowanie i Wertykalny Wycinek (Vertical Slice)

- **Prototypy:** Małe, szybkie fragmenty kodu stworzone tylko po to, by sprawdzić, czy mechanika daje frajdę (is it fun?). Często lądują w koszu po wyciągnięciu wniosków. Przykład: Prototyp skoku postaci w platformówce, by sprawdzić fizykę.
- **Vertical Slice:** To "pionowy wycinek" gry – krótki fragment (np. jedna misja), który jest dopracowany na 100% pod względem grafiki, dźwięku i kodu. Służy jako dowód jakościowy projektu dla inwestorów lub wydawcy. Przykład: Pełna misja tutorialowa z animacjami, muzyką i dialogami.

#### Analiza Ryzyka i Harmonogramowanie

Pod koniec preprodukcji powstaje Project Timeline Document. Określa on kamienie milowe i ocenia ryzyko (np. czy zespół zdąży zaimplementować nowy system fizyki). To tutaj zapada ostateczna decyzja o przejściu do kosztownej fazy produkcji właściwej.

### Produkcja Właściwa i jej fazy

To główna część tworzenia gry, podczas której powstaje kod źródłowy, zasoby graficzne (modele, tekstury) oraz oprawa dźwiękowa.

#### Klasyfikacja dźwięku w grach

- **Efekty dźwiękowe (SFX):** Odgłosy otoczenia, interakcji, walki. Przykład: Dźwięk strzału w FPS.
- **Muzyka:** Tworzona cyfrowo lub nagrywana na żywo. Przykład: Ścieżka dźwiękowa do boss fight.
- **Dialogi:** Nagrania lektorskie i dubbingowe. Przykład: Rozmowy postaci w RPG.

#### Kluczowe punkty zwrotne (Kamienie milowe)

- **Wersja Alfa:** Moment, w którym główne elementy rozgrywki są już zaimplementowane. Gra jest grywalna "od początku do końca", choć brak jej ostatecznych szlifów. Przykład: Wszystkie poziomy są dostępne, ale bez pełnej grafiki.
- **Wersja Beta:** Wszystkie funkcje i cała zawartość są gotowe. Zespół skupia się wyłącznie na usuwaniu błędów (Bug fixing) i optymalizacji wydajności. Przykład: Testy na różnych urządzeniach.
- **Wersja Złota (Gold):** Gra przechodzi certyfikację i jest gotowa do dystrybucji. Przykład: Wysłanie do sklepów cyfrowych.

### Testowanie gier komputerowych

Testowanie trwa przez cały proces produkcji.

- **Rola testerów:** Ich opinie mogą wymusić wycięcie całych systemów, jeśli nie są one zrozumiałe lub satysfakcjonujące dla gracza. Przykład: Jeśli mechanika jest zbyt skomplikowana, zostaje uproszczona.
- **QA (Quality Assurance):** Systematyczne szukanie błędów technicznych, kolizji obiektów i błędów logicznych. Przykład: Sprawdzanie, czy NPC nie wpadają w ściany.
- **Beta testy publiczne:** Pozwalają sprawdzić zachowanie tysięcy graczy jednocześnie, co jest kluczowe dla balansu rozgrywki online. Przykład: Testy multiplayer w grach jak Fortnite.

### Postprodukcja (Konserwacja)

Po premierze gra wchodzi w fazę wsparcia:

- **Patche:** Naprawa błędów zgłoszonych przez miliony graczy. Przykład: Hotfix dla crasha.
- **Live Ops:** W grach sieciowych – ciągłe dodawanie nowej zawartości, aby utrzymać zaangażowanie społeczności. Przykład: Nowe mapy w Battle Royale.
- **Optymalizacja:** Dostosowanie do nowego sprzętu i systemów operacyjnych. Przykład: Aktualizacje dla konsol nowej generacji.

### Framework MDA (Mechanics, Dynamics, Aesthetics)

Jest to **najbardziej inżynierskie podejście** do analizy i projektowania gier. Zakłada, że gra składa się z trzech warstw, które inaczej widzi twórca, a inaczej gracz.

- **Mechanika (Mechanics):** Reguły i algorytmy gry (kod, zasady). Przykład: "skok zużywa 5 punktów wytrzymałości". To perspektywa programisty.
- **Dynamika (Dynamics):** Zachowanie systemu w ruchu, wynikające z interakcji mechanik w czasie gry. Przykład: gracz zaczyna oszczędzać skoki, bo boi się utraty wytrzymałości.
- **Estetyka (Aesthetics):** Emocje wywoływane u gracza (napięcie, strach, relaks). To ostateczny cel projektowania.

**Wniosek:** Projektant tworzy Mechaniki, aby wywołać Dynamiki, które doprowadzą do określonej Estetyki (emocji).

### Projektowanie Iteracyjne (Iterative Design)

Standard w branży gier. Zamiast tworzyć "idealną" grę od razu, tworzy się ją w cyklach.

**Cykl iteracyjny:**

1. **Prototypowanie:** Szybkie stworzenie grywalnej wersji (często brzydkiej graficznie).
2. **Testowanie:** Sprawdzenie, czy gra jest zabawna (playtesting).
3. **Analiza i Poprawki:** Usunięcie błędów, balansowanie rozgrywki.
4. **Powrót do punktu 1.**

### Prototypowanie Papierowe (Paper Prototyping)

Metoda stosowana na **wczesnym etapie** projektowania. Zanim napisze się linijkę kodu, zasady gry testuje się za pomocą kart, planszówek, rysunków na papierze. Pozwala to **tanio wykryć błędy** w logice gry.

### Greyboxing (Blockout)

Metoda projektowania poziomów (Level Design). Buduje się mapę gry z szarych, prostych brył geometrycznych (bez tekstur i detali), testuje się "flow" (przepływ) rozgrywki, czytelność ścieżek i rozmiar lokacji. Dopiero gdy gameplay działa, artyści zamieniają szare bryły na gotowe modele.

### Podsumowanie na obronie

- ✅ **Preprodukcja:** GDD (High Concept, Vision, Art/Technical Docs), System/Level/Narrative Design, Prototypy, Vertical Slice, Analiza ryzyka.
- ✅ **Producja:** Kod, grafika, dźwięk (SFX, muzyka, dialogi), kamienie milowe (Alfa, Beta, Gold).
- ✅ **Testowanie:** QA, beta testy, rola testerów w poprawie UX.
- ✅ **Postprodukcja:** Patche, Live Ops, optymalizacja.
- ✅ **Metody:** MDA (Mechanika→Dynamika→Estetyka), Iteracyjne (cykle prototyp-test-poprawa), Papierowe prototypy, Greyboxing.
- ✅ **Klucz:** Preprodukcja jako fundament; sukces zależy od synchronizacji programowania, sztuki i narracji; Agile zamiast kaskadowego.

Najważniejsze to zrozumieć, że gry wymagają iteracyjnego podejścia – prototypuj, testuj, poprawiaj. Bez solidnego GDD i vertical slice'a, produkcja jest ryzykowna.

## Stachu

**[WAŻNE ŹRÓDŁO: PREZENTACJA DATKO](https://datko.pl/PiPG/wyk5.pdf)** **DATKO MY BELOVED** – kluczowe materiały do metody projektowania gier!

**Metody i fajne sposoby:**

- GDD
- Kickstarter
- Game Jam
- Agile
- Prototypowanie
- Podejście klasyczne (AAAA Ubislop)

**Modele projektowania**

1. Model kaskadowy

Polega on na wykonywaniu podstawowych czynności jako odrębnych faz projektowych, kolejno po sobie. Każda czynność to schodek (kaskady):
* Planowanie systemu (w tym specyfikacja wymagań).
* Analiza systemu (w tym analiza wymagań i studium wykonalności).
* Projekt systemu (poszczególnych struktur itp.).
* Implementacja (wytworzenie kodu).
* Testowanie (poszczególnych elementów systemu oraz elementów połączonych w całość).
* Wdrożenie i pielęgnacja powstałego systemu.
  
Jeśli któraś z faz zwróci niesatysfakcjonujący produkt, cofamy się wykonując kolejne iteracje aż do momentu kiedy otrzymamy satysfakcjonujący produkt na końcu schodków. 

2. Model przyrostowy

Fazy
* określenie całości wymagań (w ramach naszych możliwości, na tyle na ile uda nam się je sprecyzować), wykonanie wstępnego, ogólnego projektu całości systemu
* wybór pewnego podzbioru funkcji systemu
* szczegółowy projekt (według modelu kaskadowego) oraz implementacja części systemu realizującej wybrane funkcje
* testowanie zrealizowanego fragmentu i dostarczenie go klientowi
* powtarzanie kolejnych etapów, aż do zakończenia implementacji całego systemu

Zalety
* częste kontakty z klientem (skrócenie przerw w porównaniu z modelem kaskadowym)
* brak konieczności zdefiniowania z góry całości wymagań (na wstępie definiujemy, co nam się uda mając nadzieję, że uda się wyspecyfikować całość wymagań na etapie testowania zrealizowanych fragmentów)
* wczesne wykorzystanie przez klienta fragmentów systemu (funkcjonalności)
* możliwość elastycznego reagowania na opóźnienia realizacji fragmentu – przyspieszenie prac nad inną/innymi częściami (sumarycznie – bez opóźnienia całości przedsięwzięcia projektowego)

Wady
* dodatkowy koszt związany z niezależną realizacją fragmentów systemu
* potencjalne trudności z wycinaniem podzbioru funkcji w pełni niezależnych
* dlatego: konieczność implementacji szkieletów (interfejs zgodny z docelowym systemem) – dodatkowy nakład pracy (koszt), ryzyko niewykrycia błędów w fazie testowania

3. Model spiralny

Proces tworzenia ma postać spirali, której każda pętla reprezentuje jedną fazę procesu. Najbardziej wewnętrzna pętla przedstawia początkowe etapy projektowania, np. studium wykonalności, kolejna definicji wymagań systemowych itd. Patrz [spirala Boehma](https://pl.wikipedia.org/wiki/Model_spiralny)

Każda pętla spirali podzielona jest na cztery sektory:
* Ustalanie celów – definiowanie konkretnych celów wymaganych w tej fazie przedsięwzięcia. Identyfikacja ograniczeń i zagrożeń. Ustalanie planów realizacji.
* Rozpoznanie i redukcja zagrożeń – przeprowadzenie szczegółowej analizy rozpoznanych zagrożeń, ich źródeł i sposobów zapobiegania. Podejmuje się odpowiednie kroki zapobiegawcze.
* Tworzenie i zatwierdzanie – tworzenie oprogramowania w oparciu o najbardziej odpowiedni model, wybrany na podstawie oceny zagrożeń.
* Ocena i planowanie – recenzja postępu prac i planowanie kolejnej fazy przedsięwzięcia bądź zakończenie procesu produkcyjnego.

4. Model prototypowy

Polega na stworzeniu podczas projektowania prototypu w celu przedyskutowania oraz akceptacji z klientem. Po akceptacji prototypu przechodzi się do kolejnych etapów tworzenia oprogramowania. Prototypowanie zapobiega błędnemu zrozumieniu wymagań systemu, które może powodować wzrost kosztów, zwłaszcza w modelu kaskadowym. 

Rodzaje:
* Zły system, którym stosunkowo szybko się wykonuje
* Rozpisanie lub wizualizacja interfejsów na kartce
* Implementacja jedynie kilku modułów
* Użycie kreatorów w celu szybszego stworzenia interfejsów
* Implementacja metod działających jedynie w większości przypadków lub dla niektórych danych w celu pokazanie jedynie idei.

5. Projektowanie zwinne

Grupa metod zarządzania procesem produkcji oprogramowania opartego na programowaniu iteracyjno-przyrostowym. Najważniejszym założeniem metodyk zwinnych jest obserwacja, że wymagania odbiorcy (klienta) często ewoluują podczas trwania procesu produkcyjnego. Oprogramowanie wytwarzane jest przy współpracy samozarządzalnych zespołów, których celem jest przeprowadzanie procesów wytwarzania oprogramowania. 
